Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\nizam> cd "C:\Program Files\PostgreSQL\17\bin"
PS C:\Program Files\PostgreSQL\17\bin> psql -U postgres
Password for user postgres:

psql (17.6)
WARNING: Console code page (437) differs from Windows code page (1252)
         8-bit characters might not work correctly. See psql reference
         page "Notes for Windows users" for details.
Type "help" for help.

postgres=# SELECT first_name, last_name, salary
postgres-# FROM employees
postgres-# WHERE salary > (
postgres(#     SELECT AVG(salary)  -- This scalar subquery returns a single value
postgres(#     FROM employees
postgres(# );
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=# CREATE TABLE employees (
postgres(#     employee_id SERIAL PRIMARY KEY,
postgres(#     first_name VARCHAR(50),
postgres(#     last_name VARCHAR(50),
postgres(#     department VARCHAR(50),
postgres(#     salary NUMERIC(10,2),
postgres(#     manager_id INT
postgres(# );
CREATE TABLE
postgres=# INSERT INTO employees (first_name, last_name, department, salary, manager_id) VALUES
postgres-# ('Alice', 'Johnson', 'IT', 90000, NULL),      -- top-level manager
postgres-# ('Bob', 'Smith', 'IT', 70000, 1),
postgres-# ('Charlie', 'Brown', 'HR', 60000, NULL),      -- another top-level manager
postgres-# ('Diana', 'White', 'HR', 50000, 3),
postgres-# ('Eve', 'Davis', 'Finance', 65000, NULL),
postgres-# ('Frank', 'Miller', 'Finance', 48000, 5);
INSERT 0 6
postgres=# CREATE TABLE orders (
postgres(#     order_id SERIAL PRIMARY KEY,
postgres(#     customer_name VARCHAR(50),
postgres(#     region_id INT,
postgres(#     amount NUMERIC(10,2),
postgres(#     status VARCHAR(20)
postgres(# );
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=# CREATE TABLE orders (
postgres(#     order_id SERIAL PRIMARY KEY,
postgres(#     customer_name VARCHAR(50),
postgres(#     region_id INT,
postgres(#     amount NUMERIC(10,2),
postgres(#     status VARCHAR(20)
postgres(# );
CREATE TABLE
postgres=# INSERT INTO orders (customer_name, region_id, amount, status) VALUES
postgres-# ('Aibek', 1, 1200, 'High Priority'),
postgres-# ('Dana', 1, 800, 'Low Priority'),
postgres-# ('Mira', 2, 5000, 'Medium Priority'),
postgres-# ('Nurlan', 3, 15000, 'High Priority'),
postgres-# ('Samat', 2, 700, 'Low Priority');
INSERT 0 5
postgres=# CREATE TABLE warehouse_1 (
postgres(#     product_id INT,
postgres(#     product_name VARCHAR(50),
postgres(#     quantity INT
postgres(# );
CREATE TABLE
postgres=# CREATE TABLE warehouse_2 (
postgres(#     product_id INT,
postgres(#     product_name VARCHAR(50),
postgres(#     quantity INT
postgres(# );
CREATE TABLE
postgres=# INSERT INTO warehouse_1 VALUES
postgres-# (1, 'Laptop', 5),
postgres-# (2, 'Phone', 10),
postgres-# (3, 'Keyboard', 0);
INSERT 0 3
postgres=# INSERT INTO warehouse_2 VALUES
postgres-# (2, 'Phone', 3),
postgres-# (3, 'Keyboard', 0),
postgres-# (4, 'Monitor', 7);
INSERT 0 3
postgres=# CREATE TABLE sales (
postgres(#     product_name VARCHAR(50),
postgres(#     year INT,
postgres(#     sales_amount NUMERIC(10,2)
postgres(# );
CREATE TABLE
postgres=# INSERT INTO sales VALUES
postgres-# ('Laptop', 2022, 50000),
postgres-# ('Laptop', 2023, 65000),
postgres-# ('Laptop', 2024, 72000),
postgres-# ('Phone', 2022, 40000),
postgres-# ('Phone', 2023, 47000),
postgres-# ('Phone', 2024, 49000),
postgres-# ('Monitor', 2023, 30000),
postgres-# ('Monitor', 2024, 35000);
INSERT 0 8
postgres=# CREATE TABLE pivoted_sales (
postgres(#     product_name VARCHAR(50),
postgres(#     year_2022 NUMERIC(10,2),
postgres(#     year_2023 NUMERIC(10,2),
postgres(#     year_2024 NUMERIC(10,2)
postgres(# );
CREATE TABLE
postgres=# INSERT INTO pivoted_sales VALUES
postgres-# ('Laptop', 50000, 65000, 72000),
postgres-# ('Phone', 40000, 47000, 49000),
postgres-# ('Monitor', 0, 30000, 35000);
INSERT 0 3
postgres=# CREATE INDEX idx_orders_region ON orders(region_id);
CREATE INDEX
postgres=# CREATE INDEX idx_employees_department ON employees(department);
CREATE INDEX
postgres=# SELECT first_name, last_name, salary
postgres-# FROM employees
postgres-# WHERE salary > (
postgres(#     SELECT AVG(salary)  -- This scalar subquery returns a single value
postgres(#     FROM employees
postgres(# );
 first_name | last_name |  salary
------------+-----------+----------
 Alice      | Johnson   | 90000.00
 Bob        | Smith     | 70000.00
 Eve        | Davis     | 65000.00
(3 rows)


postgres=# WITH regional_sales AS (
postgres(#     SELECT region_id, SUM(amount) AS total_sales
postgres(#     FROM orders
postgres(#     GROUP BY region_id
postgres(# )
postgres-# SELECT region_id, total_sales
postgres-# FROM regional_sales
postgres-# WHERE total_sales > 1000000;
 region_id | total_sales
-----------+-------------
(0 rows)


postgres=# WITH RECURSIVE org_chart AS (
postgres(#     -- Anchor: Find the top-level manager (e.g., who has no manager)
postgres(#     SELECT employee_id, first_name, last_name, manager_id
postgres(#     FROM employees
postgres(#     WHERE manager_id IS NULL
postgres(#     UNION ALL
postgres(#     -- Recursive: Find everyone who reports to the people already in the chart
postgres(#     SELECT e.employee_id, e.first_name, e.last_name, e.manager_id
postgres(#     FROM employees e
postgres(#     INNER JOIN org_chart oc ON e.manager_id = oc.employee_id
postgres(# )
postgres-# SELECT * FROM org_chart;
 employee_id | first_name | last_name | manager_id
-------------+------------+-----------+------------
           1 | Alice      | Johnson   |
           3 | Charlie    | Brown     |
           5 | Eve        | Davis     |
           2 | Bob        | Smith     |          1
           4 | Diana      | White     |          3
           6 | Frank      | Miller    |          5
(6 rows)


postgres=# SELECT product_name FROM warehouse_1
postgres-# UNION
postgres-# SELECT product_name FROM warehouse_2;
 product_name
--------------
 Monitor
 Phone
 Laptop
 Keyboard
(4 rows)


postgres=#
postgres=# -- Find products that are out of stock in both warehouses
postgres=# SELECT product_id FROM warehouse_1 WHERE quantity = 0
postgres-# INTERSECT
postgres-# SELECT product_id FROM warehouse_2 WHERE quantity = 0;
 product_id
------------
          3
(1 row)


postgres=# SELECT
postgres-#     first_name,
postgres-#     last_name,
postgres-#     department,
postgres-#     salary,
postgres-#     RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_salary_rank
postgres-# FROM employees;
 first_name | last_name | department |  salary  | dept_salary_rank
------------+-----------+------------+----------+------------------
 Eve        | Davis     | Finance    | 65000.00 |                1
 Frank      | Miller    | Finance    | 48000.00 |                2
 Charlie    | Brown     | HR         | 60000.00 |                1
 Diana      | White     | HR         | 50000.00 |                2
 Alice      | Johnson   | IT         | 90000.00 |                1
 Bob        | Smith     | IT         | 70000.00 |                2
(6 rows)


postgres=# SELECT
postgres-#     product_name,
postgres-#     SUM(CASE WHEN year = 2022 THEN sales_amount ELSE 0 END) AS year_2022,
postgres-#     SUM(CASE WHEN year = 2023 THEN sales_amount ELSE 0 END) AS year_2023,
postgres-#     SUM(CASE WHEN year = 2024 THEN sales_amount ELSE 0 END) AS year_2024
postgres-# FROM sales
postgres-# GROUP BY product_name;
 product_name | year_2022 | year_2023 | year_2024
--------------+-----------+-----------+-----------
 Phone        |  40000.00 |  47000.00 |  49000.00
 Monitor      |         0 |  30000.00 |  35000.00
 Laptop       |  50000.00 |  65000.00 |  72000.00
(3 rows)


postgres=# Unpivoting with UNION ALL:
postgres-# SELECT product_name, '2022' AS year, year_2022 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2023' AS year, year_2023 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2024' AS year, year_2024 AS sales_amount FROM pivoted_sales
postgres-# ORDER BY product_name, year;
ERROR:  character with byte sequence 0xd0 0x9e in encoding "UTF8" has no equivalent in encoding "WIN1252"
postgres=# SELECT product_name, '2022' AS year, year_2022 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2023' AS year, year_2023 AS sales_amount FROM pivoted_sales
postgres-# UNION ALL
postgres-# SELECT product_name, '2024' AS year, year_2024 AS sales_amount FROM pivoted_sales
postgres-# ORDER BY product_name, year;
 product_name | year | sales_amount
--------------+------+--------------
 Laptop       | 2022 |     50000.00
 Laptop       | 2023 |     65000.00
 Laptop       | 2024 |     72000.00
 Monitor      | 2022 |         0.00
 Monitor      | 2023 |     30000.00
 Monitor      | 2024 |     35000.00
 Phone        | 2022 |     40000.00
 Phone        | 2023 |     47000.00
 Phone        | 2024 |     49000.00
(9 rows)


postgres=#